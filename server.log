Take My Every Code I Think Then You WillUnderSatnd 

C:\Users\epicg\Desktop\parking-management-system\views\partials\footer.ejs
<footer class="bg-dark text-white text-center py-3 mt-4">
  <p>Â© <%= new Date().getFullYear() %> Parking Management System. All rights reserved.</p>
</footer>

C:\Users\epicg\Desktop\parking-management-system\views\partials\header.ejs
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Badi Print Management System</title>
  <!-- Bootstrap CSS -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <a class="navbar-brand" href="/dashboard">Badi Print Management System</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ml-auto">
        <% if (user) { %>
          <% if (user.permissions.entry || user.username === 'superadmin') { %>
            <li class="nav-item">
              <a class="nav-link" href="/entry">Entry</a>
            </li>
          <% } %>
          <% if (user.permissions.exit || user.username === 'superadmin') { %>
            <li class="nav-item">
              <a class="nav-link" href="/exit">Exit</a>
            </li>
          <% } %>
          <% if (user.permissions.manage || user.username === 'superadmin') { %>
            <li class="nav-item">
              <a class="nav-link" href="/manage">Manage</a>
            </li>
          <% } %>
          <% if (user.permissions.profile || user.username === 'superadmin') { %>
            <li class="nav-item">
              <a class="nav-link" href="/profile">Profile</a>
            </li>
          <% } %>
          <% if (user.permissions.add_admin || user.username === 'superadmin') { %>
            <li class="nav-item">
              <a class="nav-link" href="/add-admin">Add Admin</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/manage-admins">Manage Admins</a>
            </li>
          <% } %>
          <li class="nav-item">
            <a class="nav-link" href="/logout">Logout</a>
          </li>
        <% } %>
      </ul>
    </div>
  </nav>
  <div class="container mt-4">

C:\Users\epicg\Desktop\parking-management-system\views\add-admin.ejs
<%- include('partials/header') %>
<style>
  .add-admin-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .form-group label {
    font-weight: bold;
  }
  .checkbox-group {
    margin-top: 10px;
  }
</style>
<h2 class="text-center mb-4">Add New Admin</h2>
<div class="add-admin-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <form action="/add-admin" method="POST">
    <div class="form-group">
      <label for="username">Username:</label>
      <input type="text" class="form-control" id="username" name="username" required>
    </div>
    <div class="form-group">
      <label for="password">Password:</label>
      <input type="password" class="form-control" id="password" name="password" required>
    </div>
    <div class="form-group">
      <label for="email">Email:</label>
      <input type="email" class="form-control" id="email" name="email" required>
    </div>
    <div class="form-group checkbox-group">
      <label>Permissions:</label><br>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" id="can_entry" name="can_entry">
        <label class="form-check-label" for="can_entry">Can Entry</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" id="can_exit" name="can_exit">
        <label class="form-check-label" for="can_exit">Can Exit</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" id="can_manage" name="can_manage">
        <label class="form-check-label" for="can_manage">Can Manage</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" id="can_profile" name="can_profile">
        <label class="form-check-label" for="can_profile">Can Profile</label>
      </div>
    </div>
    <button type="submit" class="btn btn-primary btn-block">Add Admin</button>
    <% if (validationErrors && validationErrors.length > 0) { %>
      <div class="alert alert-danger mt-2">
        <% validationErrors.forEach(error => { %>
          <p><%= error %></p>
        <% }) %>
      </div>
    <% } %>
  </form>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\confirm-delete-admin.ejs
<%- include('partials/header') %>
<style>
  .confirm-delete-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  .admin-info {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
  }
</style>
<h2 class="text-center mb-4">Confirm Delete Admin</h2>
<div class="confirm-delete-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <% if (!admin) { %>
    <div class="alert alert-danger text-center">Admin not found.</div>
  <% } else { %>
    <div class="admin-info">
      <h4>Admin Details</h4>
      <p><strong>Username:</strong> <%= admin.username %></p>
      <p><strong>Email:</strong> <%= admin.email %></p>
    </div>
    <p class="text-center">Are you sure you want to delete this admin? This action cannot be undone.</p>
    <form action="/manage-admins/delete/<%= admin.id %>" method="POST">
      <button type="submit" class="btn btn-danger btn-block">Yes, Delete Admin</button>
      <a href="/manage-admins" class="btn btn-secondary btn-block mt-2">Cancel</a>
    </form>
  <% } %>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\dashboard.ejs
<%- include('partials/header') %>
<style>
  .space-bar {
    height: 20px;
    margin-bottom: 10px;
  }
  .space-bar.available {
    background-color: #28a745;
  }
  .space-bar.parked {
    background-color: #dc3545;
  }
</style>
<h2 class="text-center mb-4">Dashboard</h2>
<% if (error) { %>
  <div class="alert alert-danger text-center"><%= error %></div>
<% } %>
<div class="container">
  <div class="row mb-4">
    <div class="col-md-4">
      <div class="card text-center">
        <div class="card-body">
          <h5 class="card-title">Vehicles (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h5>
          <p class="card-text"><%= vehicles %></p>
        </div>
      </div>
    </div>
    <div class="col-md-4">
      <div class="card text-center">
        <div class="card-body">
          <h5 class="card-title">Earnings (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h5>
          <p class="card-text text-center" id="earnings">PKR <%= (Number(earnings) || 0).toFixed(2) %></p>
        </div>
      </div>
    </div>
    <div class="col-md-4">
      <div class="card text-center">
        <div class="card-body">
          <h5 class="card-title">Space Usage</h5>
          <div class="space-bar available" style="width: <%= totalSpaces > 0 ? (available / totalSpaces) * 100 : 0 %>%;"></div>
          <div>Available Spaces: <%= available %></div>
          <div class="space-bar parked" style="width: <%= totalSpaces > 0 ? ((totalSpaces - available) / totalSpaces) * 100 : 0 %>%;"></div>
          <div>Used Spaces: <%= totalSpaces - available %></div>
        </div>
      </div>
    </div>
  </div>
  <div class="row mb-4">
    <div class="col-12 text-center">
      <a href="/dashboard?filter=today" class="btn btn-<%= filter === 'today' ? 'primary' : 'secondary' %> mx-2">Today</a>
      <a href="/dashboard?filter=weekly" class="btn btn-<%= filter === 'weekly' ? 'primary' : 'secondary' %> mx-2">Weekly</a>
      <a href="/dashboard?filter=monthly" class="btn btn-<%= filter === 'monthly' ? 'primary' : 'secondary' %> mx-2">Monthly</a>
    </div>
  </div>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\edit-admin.ejs
<%- include('partials/header') %>
<style>
  .edit-admin-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .form-group label {
    font-weight: bold;
  }
  .password-wrapper {
    position: relative;
  }
  .password-wrapper input[type="password"],
  .password-wrapper input[type="text"] {
    padding-right: 40px; /* Space for the eye icon */
  }
  .password-wrapper .toggle-password {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    cursor: pointer;
    color: #666;
  }
</style>
<!-- Include Bootstrap Icons CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
<h2 class="text-center mb-4">Edit Admin</h2>
<div class="edit-admin-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <% if (success) { %>
    <div class="alert alert-success text-center"><%= success %></div>
  <% } %>
  <% if (!admin) { %>
    <div class="alert alert-danger text-center">Admin not found.</div>
  <% } else { %>
    <form action="/manage-admins/edit/<%= admin.id %>" method="POST">
      <div class="form-group">
        <label for="username">Username:</label>
        <input type="text" class="form-control" id="username" name="username" value="<%= admin.username %>" required>
      </div>
      <div class="form-group">
        <label for="email">Email:</label>
        <input type="email" class="form-control" id="email" name="email" value="<%= admin.email %>" required>
      </div>
      <div class="form-group">
        <label for="password">New Password (required):</label>
        <div class="password-wrapper">
          <input type="password" class="form-control" id="password" name="password" value="<%= admin.plaintext_password || 'Password not available' %>" required>
          <i class="bi bi-eye-slash toggle-password" id="togglePassword"></i>
        </div>
      </div>
      <div class="form-group">
        <label>Permissions:</label>
        <div class="form-check">
          <input type="checkbox" class="form-check-input" id="can_entry" name="can_entry" <%= admin.permissions.entry ? 'checked' : '' %>>
          <label class="form-check-label" for="can_entry">Can Entry</label>
        </div>
        <div class="form-check">
          <input type="checkbox" class="form-check-input" id="can_exit" name="can_exit" <%= admin.permissions.exit ? 'checked' : '' %>>
          <label class="form-check-label" for="can_exit">Can Exit</label>
        </div>
        <div class="form-check">
          <input type="checkbox" class="form-check-input" id="can_manage" name="can_manage" <%= admin.permissions.manage ? 'checked' : '' %>>
          <label class="form-check-label" for="can_manage">Can Manage</label>
        </div>
        <div class="form-check">
          <input type="checkbox" class="form-check-input" id="can_profile" name="can_profile" <%= admin.permissions.profile ? 'checked' : '' %>>
          <label class="form-check-label" for="can_profile">Can Profile</label>
        </div>
      </div>
      <button type="submit" class="btn btn-primary btn-block">Update Admin</button>
      <a href="/manage-admins" class="btn btn-secondary btn-block mt-2">Cancel</a>
      <% if (validationErrors && validationErrors.length > 0) { %>
        <div class="alert alert-danger mt-2">
          <% validationErrors.forEach(error => { %>
            <p><%= error %></p>
          <% }) %>
        </div>
      <% } %>
    </form>
  <% } %>
</div>
<script>
  // JavaScript to toggle password visibility
  document.getElementById('togglePassword').addEventListener('click', function () {
    const passwordField = document.getElementById('password');
    const icon = this;
    if (passwordField.type === 'password') {
      passwordField.type = 'text';
      icon.classList.remove('bi-eye-slash');
      icon.classList.add('bi-eye');
    } else {
      passwordField.type = 'password';
      icon.classList.remove('bi-eye');
      icon.classList.add('bi-eye-slash');
    }
  });
</script>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\entry.ejs
<%- include('partials/header') %>
<style>
  .entry-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .form-group label {
    font-weight: bold;
  }
  .lot-info {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
    text-align: center;
  }
</style>
<h2 class="text-center mb-4">Vehicle Entry</h2>
<div class="entry-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <!-- Lot Information -->
  <!-- <div class="lot-info">
    <h4>Parking Lot Status</h4>
    <p>Total Spaces: <%= lot.total_spaces %> | Used Spaces: <%= lot.used_spaces %> | Available Spaces: <%= lot.total_spaces - lot.used_spaces %></p>
  </div> -->
  <!-- Entry Form -->
  <form action="/entry" method="POST">
    <div class="form-group">
      <label for="number_plate">Number Plate:</label>
      <input type="text" class="form-control" id="number_plate" name="number_plate" value="<%= autofill.number_plate || '' %>" required>
    </div>
    <div class="form-group">
      <label for="owner_name">Owner Name (Optional):</label>
      <input type="text" class="form-control" id="owner_name" name="owner_name" value="<%= autofill.owner_name || '' %>">
    </div>
    <div class="form-group">
      <label for="phone">Phone Number (Optional):</label>
      <input type="text" class="form-control" id="phone" name="phone" value="<%= autofill.phone || '' %>">
    </div>
    <div class="form-group">
      <label for="category_id">Vehicle Category:</label>
      <select class="form-control" id="category_id" name="category_id" required>
        <% categories.forEach(category => { %>
          <option value="<%= category.id %>" <%= autofill.category_id == category.id ? 'selected' : '' %>>
            <%= category.name %> (Available Spaces: <%= category.available_spaces %>)
          </option>
        <% }) %>
      </select>
    </div>
    <button type="submit" class="btn btn-primary btn-block">Add Entry</button>
    <% if (validationErrors && validationErrors.length > 0) { %>
      <div class="alert alert-danger mt-2">
        <% validationErrors.forEach(error => { %>
          <p><%= error %></p>
        <% }) %>
      </div>
    <% } %>
  </form>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\exit.ejs
<%- include('partials/header') %>
<style>
  .exit-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
  .entries-table {
    margin-top: 20px;
  }
</style>
<h2 class="text-center mb-4">Vehicle Exit</h2>
<div class="exit-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <!-- Entries Table -->
  <table class="table table-bordered entries-table">
    <thead>
      <tr>
        <th>Number Plate</th>
        <th>Entry Time</th>
        <th>Owner Name</th>
        <th>Phone</th>
        <th>Category</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody>
      <% if (entries && entries.length > 0) { %>
        <% entries.forEach(entry => { %>
          <tr>
            <td><%= entry.number_plate %></td>
            <td><%= new Date(entry.entry_time).toLocaleString() %></td>
            <td><%= entry.owner_name || 'N/A' %></td>
            <td><%= entry.phone || 'N/A' %></td>
            <td><%= entry.category || 'Unknown' %></td>
            <td>
              <form action="/exit" method="POST">
                <input type="hidden" name="entry_id" value="<%= entry.id %>">
                <button type="submit" class="btn btn-sm btn-danger" onclick="return confirm('Are you sure you want to process this exit?');">Exit</button>
              </form>
            </td>
          </tr>
        <% }) %>
      <% } else { %>
        <tr>
          <td colspan="6" class="text-center">No vehicles currently parked.</td>
        </tr>
      <% } %>
    </tbody>
  </table>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\login.ejs
<%- include('partials/header') %>
<h2 class="text-center mb-4">Login to Parking Management System</h2>
<div class="container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <form action="/login" method="POST" class="w-50 mx-auto">
    <div class="form-group">
      <label for="username">Username:</label>
      <input type="text" class="form-control" id="username" name="username" required>
    </div>
    <div class="form-group">
      <label for="password">Password:</label>
      <input type="password" class="form-control" id="password" name="password" required>
    </div>
    <button type="submit" class="btn btn-primary btn-block">Login</button>
  </form>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\manage-admins.ejs
<%- include('partials/header') %>
<style>
  .manage-admins-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
  .admins-table {
    margin-top: 20px;
  }
</style>
<h2 class="text-center mb-4">Manage Admins</h2>
<div class="manage-admins-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <% if (success) { %>
    <div class="alert alert-success text-center"><%= success %></div>
  <% } %>
  <!-- Admins Table -->
  <table class="table table-bordered admins-table">
    <thead>
      <tr>
        <th>Username</th>
        <th>Email</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <% if (admins && admins.length > 0) { %>
        <% admins.forEach(admin => { %>
          <tr>
            <td><%= admin.username %></td>
            <td><%= admin.email %></td>
            <td>
              <a href="/manage-admins/edit/<%= admin.id %>" class="btn btn-sm btn-primary">Edit</a>
              <a href="/manage-admins/confirm-delete/<%= admin.id %>" class="btn btn-sm btn-danger">Delete</a>
            </td>
          </tr>
        <% }) %>
      <% } else { %>
        <tr>
          <td colspan="3" class="text-center">No admins found.</td>
        </tr>
      <% } %>
    </tbody>
  </table>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\manage.ejs
<%- include('partials/header') %>
<style>
  .manage-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .form-group label {
    font-weight: bold;
  }
  .category-table {
    margin-top: 20px;
  }
</style>
<h2 class="text-center mb-4">Manage Parking System</h2>
<div class="manage-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <% if (success) { %>
    <div class="alert alert-success text-center"><%= success %></div>
  <% } %>
  <!-- Set Lot Spaces -->
  <h4>Set Parking Lot Spaces</h4>
  <form action="/manage/set-lot-spaces" method="POST">
    <div class="form-group">
      <label for="total_spaces">Total Spaces:</label>
      <input type="number" class="form-control" id="total_spaces" name="total_spaces" required>
    </div>
    <button type="submit" class="btn btn-primary">Set Spaces</button>
  </form>
  <hr>
  <!-- Add/Edit Category -->
  <h4><%= editCategory ? 'Edit Category' : 'Add New Category' %></h4>
  <form action="<%= editCategory ? '/manage/edit/' + editCategory.id : '/manage/add-category' %>" method="POST">
    <div class="form-group">
      <label for="name">Category Name:</label>
      <input type="text" class="form-control" id="name" name="name" value="<%= editCategory ? editCategory.name : '' %>" required>
    </div>
    <div class="form-group">
      <label for="spaces_per_vehicle">Spaces per Vehicle:</label>
      <input type="number" class="form-control" id="spaces_per_vehicle" name="spaces_per_vehicle" value="<%= editCategory ? editCategory.spaces_per_vehicle : '1' %>" required>
    </div>
    <div class="form-group">
      <label for="pricing_type">Pricing Type:</label>
      <select class="form-control" id="pricing_type" name="pricing_type" required>
        <option value="hourly" <%= editCategory && editCategory.pricing_type === 'hourly' ? 'selected' : '' %>>Hourly</option>
        <option value="per-entry" <%= editCategory && editCategory.pricing_type === 'per-entry' ? 'selected' : '' %>>Per Entry</option>
      </select>
    </div>
    <div class="form-group">
      <label for="price">Price:</label>
      <input type="number" step="0.01" class="form-control" id="price" name="price" value="<%= editCategory ? editCategory.price : '0' %>" required>
    </div>
    <button type="submit" class="btn btn-primary"><%= editCategory ? 'Update Category' : 'Add Category' %></button>
    <% if (editCategory) { %>
      <a href="/manage" class="btn btn-secondary">Cancel</a>
    <% } %>
    <% if (validationErrors && validationErrors.length > 0) { %>
      <div class="alert alert-danger mt-2">
        <% validationErrors.forEach(error => { %>
          <p><%= error %></p>
        <% }) %>
      </div>
    <% } %>
  </form>
  <hr>
  <!-- Categories Table -->
  <h4>Vehicle Categories</h4>
  <table class="table table-bordered category-table">
    <thead>
      <tr>
        <th>Name</th>
        <th>Spaces per Vehicle</th>
        <th>Pricing Type</th>
        <th>Price</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <% if (categories && categories.length > 0) { %>
        <% categories.forEach(category => { %>
          <tr>
            <td><%= category.name %></td>
            <td><%= category.spaces_per_vehicle %></td>
            <td><%= category.pricing_type.charAt(0).toUpperCase() + category.pricing_type.slice(1) %></td>
            <td>PRK <%= category.price.toFixed(2) %></td>
            <td>
              <a href="/manage/edit/<%= category.id %>" class="btn btn-sm btn-primary">Edit</a>
              <form action="/manage/delete/<%= category.id %>" method="POST" style="display:inline;">
                <button type="submit" class="btn btn-sm btn-danger" onclick="return confirm('Are you sure you want to delete this category?');">Delete</button>
              </form>
            </td>
          </tr>
        <% }) %>
      <% } else { %>
        <tr>
          <td colspan="5" class="text-center">No categories found.</td>
        </tr>
      <% } %>
    </tbody>
  </table>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\views\profile.ejs
<%- include('partials/header') %>
<style>
  .profile-container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .form-group label {
    font-weight: bold;
  }
</style>
<h2 class="text-center mb-4">Your Profile</h2>
<div class="profile-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <% if (success) { %>
    <div class="alert alert-success text-center"><%= success %></div>
  <% } %>
  <form action="/profile" method="POST">
    <div class="form-group">
      <label for="username">Username:</label>
      <input type="text" class="form-control" id="username" name="username" value="<%= admin.username %>" required>
    </div>
    <div class="form-group">
      <label for="email">Email:</label>
      <input type="email" class="form-control" id="email" name="email" value="<%= admin.email %>" required>
    </div>
    <div class="form-group">
      <label for="password">New Password (leave blank to keep current password):</label>
      <input type="password" class="form-control" id="password" name="password" placeholder="Enter new password">
    </div>
    <button type="submit" class="btn btn-primary btn-block">Update Profile</button>
    <% if (validationErrors && validationErrors.length > 0) { %>
      <div class="alert alert-danger mt-2">
        <% validationErrors.forEach(error => { %>
          <p><%= error %></p>
        <% }) %>
      </div>
    <% } %>
  </form>
</div>

C:\Users\epicg\Desktop\parking-management-system\views\public-parking.ejs
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Public Parking - Parking Management System</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="/public">Parking System</a>
    </div>
  </nav>
  <div class="container mt-4">
    <h2>Public Parking Interface</h2>
    <button id="subscribeButton" class="btn btn-info mb-3">Enable Notifications</button>
    <% if (typeof error !== 'undefined' && error && error !== 'null') { %>
      <div class="alert alert-danger"><%= error %></div>
    <% } %>
    <% if (typeof validationErrors !== 'undefined' && Array.isArray(validationErrors) && validationErrors.length > 0) { %>
      <div class="alert alert-danger">
        <ul>
          <% validationErrors.forEach(function(error) { %>
            <li><%= error %></li>
          <% }) %>
        </ul>
      </div>
    <% } %>
    <% if (Array.isArray(lots) && lots.length > 0) { %>
      <% lots.forEach(function(lot) { %>
        <div class="card mb-3">
          <div class="card-body">
            <p><strong>Total Spaces:</strong> <%= lot && lot.totalSpaces !== undefined ? lot.totalSpaces : 0 %></p>
            <p><strong>Available Spaces:</strong> <%= lot && lot.available !== undefined ? lot.available : 0 %></p>
            <h5>Pricing</h5>
            <% if (lot && Array.isArray(lot.categories) && lot.categories.length > 0) { %>
              <table class="table table-striped">
                <thead>
                  <tr>
                    <th>Category</th>
                    <th>Pricing Type</th>
                    <th>Price</th>
                  </tr>
                </thead>
                <tbody>
                  <% lot.categories.forEach(function(category) { %>
                    <tr>
                      <td><%= category && category.name ? category.name : 'N/A' %></td>
                      <td><%= category && category.pricing_type ? category.pricing_type : 'N/A' %></td>
                      <td>$<%= category && category.price !== undefined ? Number(category.price).toFixed(2) : '0.00' %></td>
                    </tr>
                  <% }) %>
                </tbody>
              </table>
            <% } else { %>
              <p>No categories available.</p>
            <% } %>
            <h5>Park Your Vehicle</h5>
            <form action="/public/park" method="POST">
              <div class="mb-3">
                <label for="number_plate" class="form-label">Number Plate</label>
                <input type="text" class="form-control" id="number_plate" name="number_plate" value="<%= autofill && autofill.number_plate ? autofill.number_plate : '' %>" required>
                <small class="form-text text-muted">3-10 characters, uppercase letters and numbers only (e.g., ABC123)</small>
              </div>
              <div class="mb-3">
                <label for="owner_name" class="form-label">Owner Name (Optional)</label>
                <input type="text" class="form-control" id="owner_name" name="owner_name" value="<%= autofill && autofill.owner_name ? autofill.owner_name : '' %>">
                <small class="form-text text-muted">1-50 characters, letters and spaces only</small>
              </div>
              <div class="mb-3">
                <label for="phone" class="form-label">Phone (Optional)</label>
                <input type="text" class="form-control" id="phone" name="phone" value="<%= autofill && autofill.phone ? autofill.phone : '' %>">
                <small class="form-text text-muted">10-15 digits</small>
              </div>
              <div class="mb-3">
                <label for="category_id" class="form-label">Vehicle Category</label>
                <select class="form-select" id="category_id" name="category_id" required>
                  <% lot.categories.forEach(function(category) { %>
                    <option value="<%= category && category.id ? category.id : '' %>" <%= autofill && autofill.category_id == category.id ? 'selected' : '' %>>
                      <%= category && category.name ? category.name : 'N/A' %>
                    </option>
                  <% }) %>
                </select>
              </div>
              <button type="submit" class="btn btn-primary">Park and Get Ticket</button>
            </form>
          </div>
        </div>
      <% }) %>
    <% } else { %>
      <p>No parking available.</p>
    <% } %>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Notification subscription
    const subscribeButton = document.getElementById('subscribeButton');
    subscribeButton.addEventListener('click', async () => {
      if ('serviceWorker' in navigator && 'PushManager' in window) {
        try {
          const registration = await navigator.serviceWorker.register('/service-worker.js');
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            const subscription = await registration.pushManager.subscribe({
              userVisibleOnly: true,
              applicationServerKey: await fetch('/vapidPublicKey').then(res => res.text())
            });
            await fetch('/subscribe', {
              method: 'POST',
              body: JSON.stringify(subscription),
              headers: { 'Content-Type': 'application/json' }
            });
            alert('Notifications enabled!');
            subscribeButton.disabled = true;
          }
        } catch (err) {
          console.error('Notification subscription error:', err);
          alert('Failed to enable notifications');
        }
      } else {
        alert('Notifications not supported in this browser');
      }
    });
  </script>
</body>
</html>

C:\Users\epicg\Desktop\parking-management-system\views\reports.ejs
<%- include('partials/header') %>
<style>
  .reports-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }
  .stats-card {
    background-color: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
    text-align: center;
    margin-bottom: 20px;
  }
  .filter-buttons {
    margin-bottom: 20px;
    text-align: center;
  }
  .filter-buttons .btn {
    margin: 0 5px;
  }
  .activity-table {
    margin-top: 20px;
  }
</style>
<h2 class="text-center mb-4">Reports</h2>
<div class="reports-container">
  <% if (error) { %>
    <div class="alert alert-danger text-center"><%= error %></div>
  <% } %>
  <!-- Filter Buttons -->
  <div class="filter-buttons">
    <a href="/reports?filter=today" class="btn <%= filter === 'today' ? 'btn-primary' : 'btn-secondary' %>">Today</a>
    <a href="/reports?filter=weekly" class="btn <%= filter === 'weekly' ? 'btn-primary' : 'btn-secondary' %>">Weekly</a>
    <a href="/reports?filter=monthly" class="btn <%= filter === 'monthly' ? 'btn-primary' : 'btn-secondary' %>">Monthly</a>
  </div>
  <!-- Stats Cards -->
  <div class="row">
    <div class="col-md-4">
      <div class="stats-card">
        <h4>Total Earnings (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h4>
        <p>$<%= totalEarnings.toFixed(2) %></p>
      </div>
    </div>
    <div class="col-md-4">
      <div class="stats-card">
        <h4>Total Entries (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h4>
        <p><%= totalEntries %></p>
      </div>
    </div>
    <div class="col-md-4">
      <div class="stats-card">
        <h4>Total Exits (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h4>
        <p><%= totalExits %></p>
      </div>
    </div>
  </div>
  <!-- Admin Activity Table -->
  <h4>Admin Activity (<%= filter.charAt(0).toUpperCase() + filter.slice(1) %>)</h4>
  <table class="table table-bordered activity-table">
    <thead>
      <tr>
        <th>Username</th>
        <th>Entries</th>
        <th>Exits</th>
      </tr>
    </thead>
    <tbody>
      <% if (adminActivity && adminActivity.length > 0) { %>
        <% adminActivity.forEach(activity => { %>
          <tr>
            <td><%= activity.username %></td>
            <td><%= activity.entries_count || 0 %></td>
            <td><%= activity.exits_count || 0 %></td>
          </tr>
        <% }) %>
      <% } else { %>
        <tr>
          <td colspan="3" class="text-center">No admin activity found.</td>
        </tr>
      <% } %>
    </tbody>
  </table>
</div>
<%- include('partials/footer') %>

C:\Users\epicg\Desktop\parking-management-system\server.js
const express = require('express');
const session = require('express-session');
const bcrypt = require('bcrypt');
const db = require('./db');
const path = require('path');
const fs = require('fs');
const webPush = require('web-push');
const activeSessions = new Map(); // Map<userId, Set<sessionId>>
require('dotenv').config();

const app = express();

// VAPID keys for Web Push (generate these once and reuse)
const vapidKeys = {
  publicKey: process.env.VAPID_PUBLIC_KEY || 'your-vapid-public-key',
  privateKey: process.env.VAPID_PRIVATE_KEY || 'your-vapid-private-key'
};

webPush.setVapidDetails(
  'mailto:your-email@example.com',
  vapidKeys.publicKey,
  vapidKeys.privateKey
);

// Middleware
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

app.use(
  session({
    secret: process.env.SESSION_SECRET || 'default-session-secret',
    resave: false,
    saveUninitialized: false,
    cookie: { 
      secure: process.env.NODE_ENV === 'production', // Use secure cookies in production (requires HTTPS)
      httpOnly: true, // Prevent client-side access to cookies
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
  })
);

app.use((req, res, next) => {
  if (req.session && req.session.admin && req.session.admin.id) {
    const userId = req.session.admin.id.toString();
    const sessionId = req.sessionID;
    if (!activeSessions.has(userId)) {
      activeSessions.set(userId, new Set());
    }
    activeSessions.get(userId).add(sessionId);
    // Clean up on session destroy
    res.on('finish', () => {
      if (req.session && req.session.destroyed) {
        activeSessions.get(userId)?.delete(sessionId);
        if (activeSessions.get(userId)?.size === 0) {
          activeSessions.delete(userId);
        }
      }
    });
  }
  next();
});

// Authentication middleware
const isAuthenticated = async (req, res, next) => {
  console.log('isAuthenticated middleware called', { sessionAdmin: req.session.admin, sessionId: req.sessionID });
  if (req.session.admin) {
    try {
      const userId = req.session.admin.id.toString();
      const sessionId = req.sessionID;
      console.log('Checking session validity:', { userId, sessionId, activeSessionsForUser: activeSessions.has(userId) ? Array.from(activeSessions.get(userId)) : null });
      // Check if this session is still valid
      if (activeSessions.has(userId) && activeSessions.get(userId).has(sessionId)) {
        // Fetch the latest admin data from the database
        const [admins] = await db.pool.query('SELECT * FROM admins WHERE id = ?', [req.session.admin.id]);
        console.log('Fetched admin from database:', admins);
        if (admins.length === 0) {
          console.log('Admin no longer exists, destroying session');
          req.session.destroy(err => {
            if (err) {
              console.error('Error destroying session:', err);
            }
            activeSessions.get(userId)?.delete(sessionId);
            if (activeSessions.get(userId)?.size === 0) {
              activeSessions.delete(userId);
            }
            res.redirect('/login');
          });
          return;
        }

        const admin = admins[0];
        // Check if username or password has changed
        const usernameMatches = admin.username === req.session.admin.username;
        let passwordMatches = true; // Default to true to avoid immediate invalidation after login
        if (req.session.admin.plaintext_password) {
          // If plaintext_password exists in the session, verify it against the database
          passwordMatches = await bcrypt.compare(req.session.admin.plaintext_password, admin.password);
        } else {
          // If plaintext_password is not set, assume credentials are invalid
          passwordMatches = false;
        }
        console.log('Credential check:', { usernameMatches, passwordMatches });
        if (!usernameMatches || !passwordMatches) {
          console.log(`Session invalidated for admin ID ${userId} due to ${!usernameMatches ? 'username' : ''}${!usernameMatches && !passwordMatches ? ' and ' : ''}${!passwordMatches ? 'password' : ''} change`);
          req.session.destroy(err => {
            if (err) {
              console.error('Error destroying session:', err);
            }
            activeSessions.get(userId)?.delete(sessionId);
            if (activeSessions.get(userId)?.size === 0) {
              activeSessions.delete(userId);
            }
            res.redirect('/login');
          });
          return;
        }

        // Update the session with the latest admin data, but preserve plaintext_password
        const plaintextPassword = req.session.admin.plaintext_password;
        req.session.admin = admin;
        req.session.admin.plaintext_password = plaintextPassword;
        if (typeof req.session.admin.permissions === 'string') {
          try {
            req.session.admin.permissions = JSON.parse(req.session.admin.permissions);
          } catch (err) {
            console.error('Error parsing permissions:', err);
            req.session.admin.permissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
          }
        } else if (!req.session.admin.permissions) {
          req.session.admin.permissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
        }
        console.log('Authenticated user:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
        next();
      } else {
        console.log('Session not found in activeSessions, destroying session');
        req.session.destroy(err => {
          if (err) {
            console.error('Error destroying session:', err);
          }
          res.redirect('/login');
        });
      }
    } catch (err) {
      console.error('Error in isAuthenticated middleware:', err);
      fs.writeFileSync('server.log', `Error in isAuthenticated middleware: ${err}\n`, { flag: 'a' });
      req.session.destroy(err => {
        if (err) {
          console.error('Error destroying session:', err);
        }
        res.redirect('/login');
      });
    }
  } else {
    console.log('No admin session found, redirecting to login');
    res.redirect('/login');
  }
};

// Permission middleware
const hasPermission = (permission) => (req, res, next) => {
  const user = req.session.admin;
  const permissions = user.permissions || {};
  console.log('Checking permission:', { user: user.username, permission, permissions });

  // Allow super admin to access all routes regardless of permissions
  if (user.username === 'superadmin') {
    console.log('Super admin access granted for:', { user: user.username, permission });
    next();
    return;
  }

  // Enforce permission check for other users
  if (permissions[permission] === true) {
    next();
  } else {
    console.log('Permission denied, redirecting to /dashboard');
    res.redirect('/dashboard');
  }
};

const invalidateUserSessions = (userId, currentSessionId) => {
  userId = userId.toString();
  if (activeSessions.has(userId)) {
    const sessionIds = activeSessions.get(userId);
    sessionIds.forEach(sessionId => {
      if (sessionId !== currentSessionId) { // Don't invalidate the super admin's session
        sessionIds.delete(sessionId);
      }
    });
    if (sessionIds.size === 0) {
      activeSessions.delete(userId);
    }
  }
};

// Validation Functions
const validateUsername = (username) => {
  const usernameRegex = /^[a-zA-Z0-9]{3,20}$/;
  if (!usernameRegex.test(username)) {
    return 'Username must be 3-20 characters and contain only letters and numbers';
  }
  return null;
};

const validatePassword = (password) => {
  if (password.length < 8) {
    return 'Password must be at least 8 characters long';
  }
  return null;
};

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return 'Invalid email format';
  }
  return null;
};

const validateCategoryName = (name) => {
  const nameRegex = /^[a-zA-Z0-9\s]{1,50}$/;
  if (!nameRegex.test(name)) {
    return 'Category name must be 1-50 characters and contain only letters, numbers, and spaces';
  }
  return null;
};

const validateTotalSpaces = (total_spaces) => {
  const num = Number(total_spaces);
  if (!Number.isInteger(num) || num < 1) {
    return 'Total spaces must be a positive integer';
  }
  return null;
};

const validateSpacesPerVehicle = (spaces_per_vehicle) => {
  const num = Number(spaces_per_vehicle);
  if (!Number.isInteger(num) || num < 1) {
    return 'Spaces per vehicle must be a positive integer';
  }
  return null;
};

const validatePricingType = (pricing_type) => {
  if (!['hourly', 'per-entry'].includes(pricing_type)) {
    return 'Pricing type must be "hourly" or "per-entry"';
  }
  return null;
};

const validatePrice = (price) => {
  const num = Number(price);
  if (isNaN(num) || num < 0) {
    return 'Price must be a positive number';
  }
  return null;
};

const validateNumberPlate = (number_plate) => {
  const plateRegex = /^[A-Z0-9]{3,10}$/;
  if (!plateRegex.test(number_plate)) {
    return 'Number plate must be 3-10 characters and contain only uppercase letters and numbers (e.g., ABC123)';
  }
  return null;
};

const validateOwnerName = (owner_name) => {
  if (owner_name && owner_name.length > 0) {
    const nameRegex = /^[a-zA-Z\s]{1,50}$/;
    if (!nameRegex.test(owner_name)) {
      return 'Owner name must be 1-50 characters and contain only letters and spaces';
    }
  }
  return null;
};

const validatePhone = (phone) => {
  if (phone && phone.length > 0) {
    const phoneRegex = /^\d{10,15}$/;
    if (!phoneRegex.test(phone)) {
      return 'Phone number must be 10-15 digits';
    }
  }
  return null;
};

// Redirect root URL to /dashboard
app.get('/', isAuthenticated, (req, res) => {
  console.log('GET / - Redirecting to /dashboard');
  res.redirect('/dashboard');
});

// Login Routes
app.get('/login', (req, res) => {
  console.log('GET /login');
  res.render('login', { error: null, success: null, user: null });
});

app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  console.log('POST /login:', { username, password: password ? '[REDACTED]' : 'Not provided' });
  try {
    const [rows] = await db.pool.query('SELECT * FROM admins WHERE username = ?', [username]);
    console.log('Database user:', rows);
    if (rows.length > 0) {
      const match = await bcrypt.compare(password, rows[0].password);
      console.log('Password match result:', match);
      if (match) {
        if (typeof rows[0].permissions === 'string') {
          rows[0].permissions = JSON.parse(rows[0].permissions);
        }
        console.log('Parsed permissions:', rows[0].permissions);
        // Store the plaintext password in the session and database
        rows[0].plaintext_password = password;
        req.session.admin = rows[0];
        console.log('Session admin set:', req.session.admin);
        // Update the plaintext_password in the database
        await db.pool.query('UPDATE admins SET plaintext_password = ? WHERE id = ?', [password, rows[0].id]);
        console.log('Updated plaintext_password in database for user:', username);
        // Explicitly save the session before redirecting
        req.session.save(err => {
          if (err) {
            console.error('Error saving session:', err);
            fs.writeFileSync('server.log', `Error saving session: ${err}\n`, { flag: 'a' });
            res.render('login', { error: 'Server error', success: null, user: null });
          } else {
            res.redirect('/');
          }
        });
      } else {
        console.log('Invalid credentials for:', username);
        res.render('login', { error: 'Invalid credentials', success: null, user: null });
      }
    } else {
      console.log('User not found:', username);
      res.render('login', { error: 'Invalid credentials', success: null, user: null });
    }
  } catch (err) {
    console.error('Login error:', err);
    fs.writeFileSync('server.log', `Login error: ${err}\n`, { flag: 'a' });
    res.render('login', { error: 'Server error', success: null, user: null });
  }
});

// Dashboard Route
app.get('/dashboard', isAuthenticated, async (req, res) => {
  console.log('GET /dashboard');
  try {
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.set('Pragma', 'no-cache');
    res.set('Expires', '0');
    res.set('Surrogate-Control', 'no-store');

    const user = req.session.admin;
    const filter = req.query.filter || 'today';
    let dateCondition = '';

    // Set todayâs date in PKT
    const today = new Date();
    const todayPKT = new Date(today.toLocaleString('en-US', { timeZone: 'Asia/Karachi' }));
    const todayPKTDateStr = todayPKT.toISOString().split('T')[0]; // e.g., "2025-05-22"
    console.log('Todayâs date (PKT):', todayPKTDateStr);

    // Adjust date condition for vehicles and earnings
    if (filter === 'weekly') {
      dateCondition = `>= DATE_SUB('${todayPKTDateStr}', INTERVAL 7 DAY)`;
    } else if (filter === 'monthly') {
      dateCondition = `>= DATE_SUB('${todayPKTDateStr}', INTERVAL 30 DAY)`;
    } else {
      dateCondition = `= '${todayPKTDateStr}'`;
    }

    // Fetch vehicle count for the selected period, converting entry_time to PKT
    const [vehicles] = await db.pool.query(
      `SELECT COUNT(*) as count 
       FROM entries 
       WHERE DATE(CONVERT_TZ(entry_time, '+00:00', '+05:00')) ${dateCondition}`
    );

    // Fetch earnings for the selected period, converting exit_time to PKT
    const [earnings] = await db.pool.query(
      `SELECT COALESCE(SUM(x.cost), 0) as total 
       FROM exits x 
       WHERE DATE(CONVERT_TZ(x.exit_time, '+00:00', '+05:00')) ${dateCondition}`
    );

    // Fetch currently parked vehicles to calculate used spaces
    const [parkedVehicles] = await db.pool.query(
      `SELECT e.category_id, vc.spaces_per_vehicle 
       FROM entries e 
       JOIN vehicle_categories vc ON e.category_id = vc.id 
       WHERE e.id NOT IN (SELECT entry_id FROM exits)`
    );

    // Fetch total spaces from parking lot
    const [lot] = await db.pool.query('SELECT total_spaces FROM parking_lot WHERE id = 1');

    const totalSpaces = lot.length > 0 ? Number(lot[0].total_spaces) || 0 : 0;
    const totalUsedSpaces = parkedVehicles.reduce((sum, vehicle) => {
      return sum + (Number(vehicle.spaces_per_vehicle) || 1);
    }, 0);
    const parkedCount = parkedVehicles.length;
    const available = totalSpaces - totalUsedSpaces;

    console.log('Dashboard queries:', { vehicles: vehicles[0], earnings: earnings[0], parkedCount, totalUsedSpaces, totalSpaces, available });

    const renderData = {
      vehicles: vehicles[0].count || 0,
      earnings: Number(earnings[0].total) || 0,
      available,
      parked: parkedCount,
      totalSpaces,
      filter,
      error: null,
      success: null,
      user
    };
    console.log('Rendering dashboard with:', renderData);

    res.render('dashboard', renderData);
  } catch (err) {
    console.error('Dashboard error:', err);
    fs.writeFileSync('server.log', `Dashboard error: ${err}\n`, { flag: 'a' });
    res.render('dashboard', {
      vehicles: 0,
      earnings: 0,
      available: 0,
      parked: 0,
      totalSpaces: 0,
      filter: 'today',
      error: 'Server error: ' + err.message,
      success: null,
      user: req.session.admin,
      hardRefresh: null
    });
  }
});

app.get('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('GET /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  try {
    const user = req.session.admin;
    res.render('profile', { admin: user, error: null, success: null, validationErrors: [], user });
  } catch (err) {
    console.error('Profile error:', err);
    fs.writeFileSync('server.log', `Profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: req.session.admin, error: 'Server error: ' + err.message, success: null, validationErrors: [], user: req.session.admin });
  }
});

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    // Refresh the session with updated admin data
    const [updatedAdmin] = await db.pool.query('SELECT * FROM admins WHERE id = ?', [user.id]);
    req.session.admin = updatedAdmin[0];
    if (typeof req.session.admin.permissions === 'string') {
      req.session.admin.permissions = JSON.parse(req.session.admin.permissions);
    }

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: req.session.admin, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user: req.session.admin });
  }
});

// Manage Routes
app.get('/manage', isAuthenticated, hasPermission('manage'), async (req, res) => {
  console.log('GET /manage');
  try {
    const user = req.session.admin;
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    console.log('Manage data:', { categories: formattedCategories });
    res.render('manage', { categories: formattedCategories, error: null, success: null, editCategory: null, validationErrors: [], user });
  } catch (err) {
    console.error('Manage error:', err);
    fs.writeFileSync('server.log', `Manage error: ${err}\n`, { flag: 'a' });
    res.render('manage', { categories: [], error: 'Server error', success: null, editCategory: null, validationErrors: [], user: req.session.admin });
  }
});

app.post('/manage/set-lot-spaces', isAuthenticated, hasPermission('manage'), async (req, res) => {
  const user = req.session.admin;
  const { total_spaces } = req.body;
  console.log('POST /manage/set-lot-spaces:', { total_spaces });

  const validationErrors = [];
  const spacesError = validateTotalSpaces(total_spaces);

  if (spacesError) validationErrors.push(spacesError);

  if (validationErrors.length > 0) {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    return res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: null, 
      editCategory: null, 
      validationErrors,
      user
    });
  }

  let usedSpaces = 0;
  try {
    const [lot] = await db.pool.query('SELECT used_spaces FROM parking_lot WHERE id = 1');
    usedSpaces = lot.length > 0 && lot[0].used_spaces !== undefined ? Number(lot[0].used_spaces) || 0 : 0;
    const newTotalSpaces = Number(total_spaces);

    if (newTotalSpaces < usedSpaces) {
      const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
      const formattedCategories = categories.map(category => ({
        ...category,
        price: Number(category.price) || 0,
        spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
      }));
      validationErrors.push(`Total spaces (${newTotalSpaces}) cannot be less than used spaces (${usedSpaces})`);
      return res.render('manage', { 
        categories: formattedCategories, 
        error: null, 
        success: null, 
        editCategory: null, 
        validationErrors,
        user
      });
    }

    await db.pool.query(
      'INSERT INTO parking_lot (id, total_spaces, used_spaces) VALUES (1, ?, ?) ON DUPLICATE KEY UPDATE total_spaces = ?',
      [newTotalSpaces, usedSpaces, newTotalSpaces]
    );

    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: 'Total spaces updated successfully', 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Set lot spaces error:', err);
    fs.writeFileSync('server.log', `Set lot spaces error: ${err}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: 'Failed to set total spaces: ' + err.message, 
      success: null, 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  }
});

app.post('/manage-admins/delete/:id', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  console.log('POST /manage-admins/delete/:id');
  const user = req.session.admin;
  const { id } = req.params;
  try {
    const [admins] = await db.pool.query('SELECT id, username, email, permissions FROM admins WHERE id = ? AND username != ?', [id, user.username]);
    if (admins.length === 0) {
      const [allAdmins] = await db.pool.query('SELECT id, username, email, permissions FROM admins WHERE username != ?', [user.username]);
      const parsedAllAdmins = allAdmins.map(admin => {
        let parsedPermissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
        if (admin.permissions) {
          try {
            parsedPermissions = { ...parsedPermissions, ...JSON.parse(admin.permissions) };
          } catch (err) {
            console.error(`Error parsing permissions for admin ${admin.username}:`, err);
          }
        }
        return { ...admin, permissions: parsedPermissions };
      });
      return res.render('manage-admins', { admins: parsedAllAdmins, error: 'Admin not found or cannot delete yourself', success: null, user });
    }

    await db.pool.query('DELETE FROM admins WHERE id = ?', [id]);
    console.log('Admin deleted:', { id });

    const [updatedAdmins] = await db.pool.query('SELECT id, username, email, permissions FROM admins WHERE username != ?', [user.username]);
    const parsedUpdatedAdmins = updatedAdmins.map(admin => {
      let parsedPermissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
      if (admin.permissions) {
        try {
          parsedPermissions = { ...parsedPermissions, ...JSON.parse(admin.permissions) };
        } catch (err) {
          console.error(`Error parsing permissions for admin ${admin.username}:`, err);
        }
      }
      return { ...admin, permissions: parsedPermissions };
    });
    res.render('manage-admins', { admins: parsedUpdatedAdmins, error: null, success: 'Admin deleted successfully', user });
  } catch (err) {
    console.error('Delete admin error:', err);
    fs.writeFileSync('server.log', `Delete admin error: ${err}\n`, { flag: 'a' });
    const [admins] = await db.pool.query('SELECT id, username, email, permissions FROM admins WHERE username != ?', [user.username]);
    const parsedAdmins = admins.map(admin => {
      let parsedPermissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
      if (admin.permissions) {
        try {
          parsedPermissions = { ...parsedPermissions, ...JSON.parse(admin.permissions) };
        } catch (err) {
          console.error(`Error parsing permissions for admin ${admin.username}:`, err);
        }
      }
      return { ...admin, permissions: parsedPermissions };
    });
    res.render('manage-admins', { admins: parsedAdmins, error: 'Failed to delete admin: ' + err.message, success: null, user });
  }
});

app.post('/manage/add-category', isAuthenticated, hasPermission('manage'), async (req, res) => {
  const user = req.session.admin;
  const { name, spaces_per_vehicle, pricing_type, price } = req.body;
  console.log('POST /manage/add-category:', { name, spaces_per_vehicle, pricing_type, price });
  
  const validationErrors = [];
  const nameError = validateCategoryName(name);
  const spacesPerVehicleError = validateSpacesPerVehicle(spaces_per_vehicle);
  const pricingError = validatePricingType(pricing_type);
  const priceError = validatePrice(price);

  if (nameError) validationErrors.push(nameError);
  if (spacesPerVehicleError) validationErrors.push(spacesPerVehicleError);
  if (pricingError) validationErrors.push(pricingError);
  if (priceError) validationErrors.push(priceError);

  if (validationErrors.length > 0) {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    return res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: null, 
      editCategory: null, 
      validationErrors,
      user
    });
  }

  try {
    await db.pool.query(
      'INSERT INTO vehicle_categories (name, spaces_per_vehicle, pricing_type, price) VALUES (?, ?, ?, ?)',
      [name, spaces_per_vehicle, pricing_type, price]
    );
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: 'Category added successfully', 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Add category error:', err);
    fs.writeFileSync('server.log', `Add category error: ${err}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: 'Failed to add category', 
      success: null, 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  }
});

app.get('/manage/edit/:id', isAuthenticated, hasPermission('manage'), async (req, res) => {
  const user = req.session.admin;
  const { id } = req.params;
  console.log('GET /manage/edit/:id:', { id });
  try {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [category] = await db.pool.query('SELECT * FROM vehicle_categories WHERE id = ?', [id]);
    if (category.length === 0) {
      const formattedCategories = categories.map(cat => ({
        ...cat,
        price: Number(cat.price) || 0,
        spaces_per_vehicle: Number(cat.spaces_per_vehicle) || 1
      }));
      return res.render('manage', { 
        categories: formattedCategories, 
        error: 'Category not found', 
        success: null, 
        editCategory: null, 
        validationErrors: [], 
        user
      });
    }
    const formattedCategories = categories.map(cat => ({
      ...cat,
      price: Number(cat.price) || 0,
      spaces_per_vehicle: Number(cat.spaces_per_vehicle) || 1
    }));
    const formattedCategory = { 
      ...category[0], 
      price: Number(category[0].price) || 0,
      spaces_per_vehicle: Number(category[0].spaces_per_vehicle) || 1
    };
    res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: null, 
      editCategory: formattedCategory, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Edit category fetch error:', err);
    fs.writeFileSync('server.log', `Edit category fetch error: ${err}\n`, { flag: 'a' });
    res.render('manage', { 
      categories: [], 
      error: 'Server error', 
      success: null, 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  }
});

app.post('/manage/edit/:id', isAuthenticated, hasPermission('manage'), async (req, res) => {
  const user = req.session.admin;
  const { id } = req.params;
  const { name, spaces_per_vehicle, pricing_type, price } = req.body;
  console.log('POST /manage/edit/:id:', { id, name, spaces_per_vehicle, pricing_type, price });

  const validationErrors = [];
  const nameError = validateCategoryName(name);
  const spacesPerVehicleError = validateSpacesPerVehicle(spaces_per_vehicle);
  const pricingError = validatePricingType(pricing_type);
  const priceError = validatePrice(price);

  if (nameError) validationErrors.push(nameError);
  if (spacesPerVehicleError) validationErrors.push(spacesPerVehicleError);
  if (pricingError) validationErrors.push(pricingError);
  if (priceError) validationErrors.push(priceError);

  if (validationErrors.length > 0) {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    return res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: null, 
      editCategory: { id, name, spaces_per_vehicle, pricing_type, price: Number(price) || 0 }, 
      validationErrors,
      user
    });
  }

  try {
    await db.pool.query(
      'UPDATE vehicle_categories SET name = ?, spaces_per_vehicle = ?, pricing_type = ?, price = ? WHERE id = ?',
      [name, spaces_per_vehicle, pricing_type, price, id]
    );
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: 'Category updated successfully', 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Edit category update error:', err);
    fs.writeFileSync('server.log', `Edit category update error: ${err}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: 'Failed to update category: ' + err.message, 
      success: null, 
      editCategory: { id, name, spaces_per_vehicle, pricing_type, price: Number(price) || 0 },
      validationErrors: [],
      user
    });
  }
});

app.post('/manage/delete/:id', isAuthenticated, hasPermission('manage'), async (req, res) => {
  const user = req.session.admin;
  const { id } = req.params;
  console.log('POST /manage/delete/:id:', { id });
  try {
    const [entries] = await db.pool.query(
      'SELECT * FROM entries WHERE category_id = ? AND CAST(id AS SIGNED) NOT IN (SELECT CAST(entry_id AS SIGNED) FROM exits WHERE entry_id IS NOT NULL)',
      [id]
    );
    console.log('Entries blocking deletion:', entries);
    if (entries.length > 0) {
      const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
      const formattedCategories = categories.map(category => ({
        ...category,
        price: Number(category.price) || 0,
        spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
      }));
      return res.render('manage', { 
        categories: formattedCategories, 
        error: 'Cannot delete category: it is in use by existing entries that have not exited', 
        success: null, 
        editCategory: null, 
        validationErrors: [], 
        user
      });
    }

    try {
      await db.pool.query('ALTER TABLE entries DROP FOREIGN KEY entries_ibfk_1');
      console.log('Dropped foreign key constraint entries_ibfk_1');
    } catch (err) {
      console.warn('Foreign key constraint entries_ibfk_1 may not exist:', err.message);
    }

    try {
      await db.pool.query('ALTER TABLE exits DROP FOREIGN KEY exits_ibfk_1');
      console.log('Dropped foreign key constraint exits_ibfk_1');
    } catch (err) {
      console.warn('Foreign key constraint exits_ibfk_1 may not exist:', err.message);
    }

    const [deleteEntriesResult] = await db.pool.query(
      'DELETE FROM entries WHERE category_id = ?',
      [id]
    );
    console.log('Deleted entries for category:', { category_id: id, affectedRows: deleteEntriesResult.affectedRows });

    const [deleteCategoryResult] = await db.pool.query('DELETE FROM vehicle_categories WHERE id = ?', [id]);
    console.log('Deleted category:', { category_id: id, affectedRows: deleteCategoryResult.affectedRows });

    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: null, 
      success: 'Category deleted successfully', 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Delete category error:', err.message, err.stack);
    fs.writeFileSync('server.log', `Delete category error: ${err.message}\n${err.stack}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const formattedCategories = categories.map(category => ({
      ...category,
      price: Number(category.price) || 0,
      spaces_per_vehicle: Number(category.spaces_per_vehicle) || 1
    }));
    res.render('manage', { 
      categories: formattedCategories, 
      error: 'Failed to delete category: ' + err.message, 
      success: null, 
      editCategory: null, 
      validationErrors: [], 
      user
    });
  }
});

// Public Routes
app.get('/public', async (req, res) => {
  console.log('GET /public');
  try {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lot] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lot.length > 0 ? {
      total_spaces: Number(lot[0].total_spaces) || 0,
      used_spaces: Number(lot[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const available = formattedLot.total_spaces - formattedLot.used_spaces;
    const lotDetails = { categories, available, totalSpaces: formattedLot.total_spaces };
    res.render('public-parking', { lots: [lotDetails], error: null, success: null, validationErrors: [], autofill: {}, user: null });
  } catch (err) {
    console.error('Public page error:', err);
    fs.writeFileSync('server.log', `Public page error: ${err}\n`, { flag: 'a' });
    res.render('public-parking', { lots: [], error: 'Server error', success: null, validationErrors: [], autofill: {}, user: null });
  }
});

app.post('/public/park', async (req, res) => {
  const { number_plate, owner_name, phone, category_id } = req.body;
  console.log('POST /public/park:', { number_plate, owner_name, phone, category_id });

  const validationErrors = [];
  const plateError = validateNumberPlate(number_plate);
  const ownerError = validateOwnerName(owner_name);
  const phoneError = validatePhone(phone);

  let categoryError = null;
  const [categoryCheck] = await db.pool.query('SELECT id, spaces_per_vehicle FROM vehicle_categories WHERE id = ?', [category_id]);
  const [lot] = await db.pool.query('SELECT total_spaces, used_spaces FROM parking_lot WHERE id = 1');
  if (categoryCheck.length === 0) {
    categoryError = 'Selected category does not exist';
  } else if (lot.length === 0) {
    categoryError = 'Parking lot configuration not found';
  } else {
    const spacesPerVehicle = Number(categoryCheck[0].spaces_per_vehicle) || 1;
    const totalSpaces = Number(lot[0].total_spaces) || 0;
    const usedSpaces = Number(lot[0].used_spaces) || 0;
    const availableSpaces = totalSpaces - usedSpaces;
    if (availableSpaces < spacesPerVehicle) {
      categoryError = `Not enough spaces available in the lot. Required: ${spacesPerVehicle}, Available: ${availableSpaces}`;
    }
  }

  if (plateError) validationErrors.push(plateError);
  if (ownerError) validationErrors.push(ownerError);
  if (phoneError) validationErrors.push(phoneError);
  if (categoryError) validationErrors.push(categoryError);

  if (validationErrors.length > 0) {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lotData] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lotData.length > 0 ? {
      total_spaces: Number(lotData[0].total_spaces) || 0,
      used_spaces: Number(lotData[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const available = formattedLot.total_spaces - formattedLot.used_spaces;
    const lotDetails = { categories, available, totalSpaces: formattedLot.total_spaces };
    return res.render('public-parking', { 
      lots: [lotDetails], 
      error: null, 
      success: null,
      validationErrors,
      autofill: { number_plate, owner_name, phone, category_id },
      user: null
    });
  }

  try {
    const connection = await db.pool.getConnection();
    try {
      await connection.beginTransaction();

      const [entryResult] = await connection.query(
        'INSERT INTO entries (number_plate, owner_name, phone, category_id, entry_time) VALUES (?, ?, ?, ?, NOW())',
        [number_plate, owner_name || null, phone || null, category_id]
      );
      const entryId = entryResult.insertId;

      const spacesPerVehicle = Number(categoryCheck[0].spaces_per_vehicle) || 1;
      await connection.query(
        'UPDATE parking_lot SET used_spaces = used_spaces + ? WHERE id = 1',
        [spacesPerVehicle]
      );

      await connection.commit();
      connection.release();

      if (req.session.subscription) {
        const payload = JSON.stringify({
          title: 'Vehicle Parked',
          body: `Your vehicle ${number_plate} has been parked.`
        });
        await webPush.sendNotification(req.session.subscription, payload);
      }

      const ticketContent = `
        <div style="text-align: center; font-family: Arial, sans-serif; padding: 20px;">
          <h2>Parking System</h2>
          <h4>Entry Ticket</h4>
          <p><strong>Vehicle Number:</strong> ${number_plate}</p>
          <p><strong>Entry Time:</strong> ${new Date().toLocaleString()}</p>
        </div>
      `;

      // Serve as HTML, let client-side script handle PDF generation
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Entry Ticket</title>
          <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
        </head>
        <body>
          <div id="ticket">${ticketContent}</div>
          <script>
            const element = document.getElementById('ticket');
            html2pdf().from(element).save('entry_ticket_${number_plate}_${Date.now()}.pdf');
            setTimeout(() => { window.location.href = '/public'; }, 1000);
          </script>
        </body>
        </html>
      `);
    } catch (err) {
      await connection.rollback();
      connection.release();
      throw err;
    }
  } catch (err) {
    console.error('Public park error:', err);
    fs.writeFileSync('server.log', `Public park error: ${err}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lotData] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lotData.length > 0 ? {
      total_spaces: Number(lotData[0].total_spaces) || 0,
      used_spaces: Number(lotData[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const available = formattedLot.total_spaces - formattedLot.used_spaces;
    const lotDetails = { categories, available, totalSpaces: formattedLot.total_spaces };
    res.render('public-parking', { 
      lots: [lotDetails], 
      error: 'Failed to park vehicle: ' + err.message, 
      success: null,
      validationErrors: [],
      autofill: { number_plate, owner_name, phone, category_id },
      user: null
    });
  }
});

// Profile Routes
// Profile Routes
// Profile Routes

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    // Refresh the session with updated admin data
    const [updatedAdmin] = await db.pool.query('SELECT * FROM admins WHERE id = ?', [user.id]);
    req.session.admin = updatedAdmin[0];
    if (typeof req.session.admin.permissions === 'string') {
      req.session.admin.permissions = JSON.parse(req.session.admin.permissions);
    }

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: req.session.admin, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user: req.session.admin });
  }
});

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    // Refresh the session with updated admin data
    const [updatedAdmin] = await db.pool.query('SELECT * FROM admins WHERE id = ?', [user.id]);
    req.session.admin = updatedAdmin[0];
    if (typeof req.session.admin.permissions === 'string') {
      req.session.admin.permissions = JSON.parse(req.session.admin.permissions);
    }

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: req.session.admin, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user: req.session.admin });
  }
});

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    req.session.admin = {
      ...req.session.admin,
      username,
      email,
      password: hashedPassword,
      plaintext_password: plaintextPassword
    };

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: req.session.admin, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user: req.session.admin });
  }
});

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    req.session.admin = {
      ...req.session.admin,
      username,
      email,
      password: hashedPassword,
      plaintext_password: plaintextPassword
    };

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: user, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user });
  }
});

app.post('/profile', isAuthenticated, hasPermission('profile'), async (req, res) => {
  console.log('POST /profile');
  console.log('User accessing profile:', { username: req.session.admin.username, permissions: req.session.admin.permissions });
  const user = req.session.admin;
  const { username, email, password } = req.body;
  console.log('POST /profile:', { username, email, password: password ? '[REDACTED]' : 'Not provided' });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const emailError = validateEmail(email);
  let passwordError = null;
  if (password) {
    passwordError = validatePassword(password);
  }

  if (usernameError) validationErrors.push(usernameError);
  if (emailError) validationErrors.push(emailError);
  if (passwordError) validationErrors.push(passwordError);

  const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, user.id]);
  if (duplicateUsername.length > 0) {
    validationErrors.push('Username already exists');
  }
  const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, user.id]);
  if (duplicateEmail.length > 0) {
    validationErrors.push('Email already exists');
  }

  if (validationErrors.length > 0) {
    return res.render('profile', { admin: user, error: null, success: null, validationErrors, user });
  }

  try {
    let hashedPassword = user.password;
    let plaintextPassword = user.plaintext_password;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
      plaintextPassword = password;
    }

    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ? WHERE id = ?',
      [username, email, hashedPassword, plaintextPassword, user.id]
    );

    req.session.admin = {
      ...req.session.admin,
      username,
      email,
      password: hashedPassword,
      plaintext_password: plaintextPassword
    };

    res.render('profile', { admin: req.session.admin, error: null, success: 'Profile updated successfully', validationErrors: [], user: req.session.admin });
  } catch (err) {
    console.error('Update profile error:', err);
    fs.writeFileSync('server.log', `Update profile error: ${err}\n`, { flag: 'a' });
    res.render('profile', { admin: user, error: 'Failed to update profile: ' + err.message, success: null, validationErrors: [], user });
  }
});

// Entry Routes
app.get('/entry', isAuthenticated, hasPermission('entry'), async (req, res) => {
  console.log('GET /entry');
  try {
    const user = req.session.admin;
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lot] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lot.length > 0 ? {
      total_spaces: Number(lot[0].total_spaces) || 0,
      used_spaces: Number(lot[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const formattedCategories = categories.map(category => ({
      ...category,
      available_spaces: formattedLot.total_spaces - formattedLot.used_spaces
    }));
    console.log('Entry categories:', formattedCategories, 'Lot:', formattedLot);
    res.render('entry', { 
      categories: formattedCategories, 
      lot: formattedLot, 
      error: null, 
      success: null,
      autofill: {}, 
      validationErrors: [], 
      user
    });
  } catch (err) {
    console.error('Entry error:', err);
    fs.writeFileSync('server.log', `Entry error: ${err}\n`, { flag: 'a' });
    res.render('entry', { 
      categories: [], 
      lot: { total_spaces: 0, used_spaces: 0 }, 
      error: 'Server error', 
      success: null,
      autofill: {}, 
      validationErrors: [], 
      user: req.session.admin
    });
  }
});

app.post('/entry', isAuthenticated, hasPermission('entry'), async (req, res) => {
  const user = req.session.admin;
  const { number_plate, owner_name, phone, category_id } = req.body;
  console.log('POST /entry:', { number_plate, owner_name, phone, category_id });

  const validationErrors = [];
  const plateError = validateNumberPlate(number_plate);
  const ownerError = validateOwnerName(owner_name);
  const phoneError = validatePhone(phone);

  let categoryError = null;
  const [categoryCheck] = await db.pool.query('SELECT id, spaces_per_vehicle, name FROM vehicle_categories WHERE id = ?', [category_id]);
  const [lot] = await db.pool.query('SELECT total_spaces, used_spaces FROM parking_lot WHERE id = 1');
  if (categoryCheck.length === 0) {
    categoryError = 'Selected category does not exist';
  } else if (lot.length === 0) {
    categoryError = 'Parking lot configuration not found';
  } else {
    const spacesPerVehicle = Number(categoryCheck[0].spaces_per_vehicle) || 1;
    const totalSpaces = Number(lot[0].total_spaces) || 0;
    const usedSpaces = Number(lot[0].used_spaces) || 0;
    const availableSpaces = totalSpaces - usedSpaces;
    if (availableSpaces < spacesPerVehicle) {
      categoryError = `Not enough spaces available in the lot. Required: ${spacesPerVehicle}, Available: ${availableSpaces}`;
    }
  }

  if (plateError) validationErrors.push(plateError);
  if (ownerError) validationErrors.push(ownerError);
  if (phoneError) validationErrors.push(phoneError);
  if (categoryError) validationErrors.push(categoryError);

  if (validationErrors.length > 0) {
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lotData] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lotData.length > 0 ? {
      total_spaces: Number(lotData[0].total_spaces) || 0,
      used_spaces: Number(lotData[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const formattedCategories = categories.map(category => ({
      ...category,
      available_spaces: formattedLot.total_spaces - formattedLot.used_spaces
    }));
    return res.render('entry', { 
      categories: formattedCategories, 
      lot: formattedLot, 
      error: null, 
      success: null,
      autofill: { number_plate, owner_name, phone, category_id }, 
      validationErrors,
      user
    });
  }

  try {
    const [existing] = await db.pool.query(
      'SELECT owner_name, phone FROM entries WHERE number_plate = ? ORDER BY entry_time DESC LIMIT 1',
      [number_plate]
    );
    const autofill = {
      number_plate,
      owner_name: owner_name || (existing.length > 0 ? existing[0].owner_name : ''),
      phone: phone || (existing.length > 0 ? existing[0].phone : ''),
      category_id
    };
    console.log('Autofill data:', autofill);

    const connection = await db.pool.getConnection();
    try {
      await connection.beginTransaction();

      const [entryResult] = await connection.query(
        'INSERT INTO entries (number_plate, owner_name, phone, category_id, entry_time) VALUES (?, ?, ?, ?, NOW())',
        [number_plate, owner_name || null, phone || null, category_id]
      );

      const spacesPerVehicle = Number(categoryCheck[0].spaces_per_vehicle) || 1;
      await connection.query(
        'UPDATE parking_lot SET used_spaces = used_spaces + ? WHERE id = 1',
        [spacesPerVehicle]
      );

      await connection.commit();
      connection.release();

      // Fetch the newly created entry to get the entry_time
      const [newEntry] = await db.pool.query('SELECT entry_time FROM entries WHERE id = ?', [entryResult.insertId]);
      const entryTime = new Date(newEntry[0].entry_time).toLocaleString();

      // Generate the receipt content
      const receiptContent = `
        <div style="text-align: center; font-family: Arial, sans-serif; padding: 20px;">
          <h2>Parking System</h2>
          <h4>Entry Receipt</h4>
          <p><strong>Vehicle Number:</strong> ${number_plate}</p>
          <p><strong>Category:</strong> ${categoryCheck[0].name}</p>
          <p><strong>Owner Name:</strong> ${owner_name || 'N/A'}</p>
          <p><strong>Phone:</strong> ${phone || 'N/A'}</p>
          <p><strong>Entry Time:</strong> ${entryTime}</p>
          <p><strong>Added By:</strong> ${user.username}</p>
        </div>
      `;

      // Serve as HTML, let client-side script handle PDF generation
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Entry Receipt</title>
          <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
        </head>
        <body>
          <div id="receipt">${receiptContent}</div>
          <script>
            const element = document.getElementById('receipt');
            html2pdf().from(element).save('entry_receipt_${number_plate}_${Date.now()}.pdf');
            setTimeout(() => { window.location.href = '/dashboard'; }, 1000);
          </script>
        </body>
        </html>
      `);
    } catch (err) {
      await connection.rollback();
      connection.release();
      throw err;
    }
  } catch (err) {
    console.error('Add entry error:', err);
    fs.writeFileSync('server.log', `Add entry error: ${err}\n`, { flag: 'a' });
    const [categories] = await db.pool.query('SELECT * FROM vehicle_categories');
    const [lotData] = await db.pool.query('SELECT * FROM parking_lot WHERE id = 1');
    const formattedLot = lotData.length > 0 ? {
      total_spaces: Number(lotData[0].total_spaces) || 0,
      used_spaces: Number(lotData[0].used_spaces) || 0
    } : { total_spaces: 0, used_spaces: 0 };
    const formattedCategories = categories.map(category => ({
      ...category,
      available_spaces: formattedLot.total_spaces - formattedLot.used_spaces
    }));
    res.render('entry', { 
      categories: formattedCategories, 
      lot: formattedLot, 
      error: 'Failed to add entry: ' + err.message, 
      success: null,
      autofill: { number_plate, owner_name, phone, category_id }, 
      validationErrors: [],
      user
    });
  }
});

// Exit Routes
app.get('/exit', isAuthenticated, hasPermission('exit'), async (req, res) => {
  console.log('GET /exit');
  try {
    const user = req.session.admin;
    const [entries] = await db.pool.query(
      'SELECT e.id, e.number_plate, e.entry_time, e.owner_name, e.phone, e.category_id, vc.name as category, vc.pricing_type, vc.price, vc.spaces_per_vehicle ' +
      'FROM entries e LEFT JOIN vehicle_categories vc ON e.category_id = vc.id'
    );
    console.log('Exit entries:', entries);
    res.render('exit', { entries: entries || [], error: null, success: null, user });
  } catch (err) {
    console.error('Exit error:', err);
    fs.writeFileSync('server.log', `Exit error: ${err}\n`, { flag: 'a' });
    res.render('exit', { entries: [], error: 'Server error', success: null, user: req.session.admin });
  }
});

app.post('/exit', isAuthenticated, hasPermission('exit'), async (req, res) => {
  const user = req.session.admin;
  const { entry_id } = req.body;
  console.log('POST /exit:', { entry_id });

  try {
    const [parkedBefore] = await db.pool.query(
      `SELECT COUNT(*) as count FROM entries`
    );
    const [earningsBefore] = await db.pool.query(
      `SELECT COALESCE(SUM(x.cost), 0) as total FROM exits x WHERE DATE(x.exit_time) = CURDATE()`
    );
    console.log('Dashboard stats before exit:', { parked: parkedBefore[0].count, earnings: earningsBefore[0].total });

    const [entry] = await db.pool.query(
      'SELECT e.entry_time, e.number_plate, e.category_id, vc.pricing_type, vc.price, vc.spaces_per_vehicle, vc.name as category ' +
      'FROM entries e JOIN vehicle_categories vc ON e.category_id = vc.id ' +
      'WHERE e.id = ?',
      [entry_id]
    );
    console.log('Exit entry:', entry);
    if (entry.length === 0) {
      console.log('Entry not found for exit:', { entry_id });
      return res.status(404).send('Entry not found');
    }

    const entryTime = new Date(entry[0].entry_time).toLocaleString();
    const exitTime = new Date();
    const exitTimeFormatted = exitTime.toLocaleString();
    let cost = 0;
    if (entry[0].pricing_type === 'hourly') {
      const hours = Math.ceil((exitTime - new Date(entry[0].entry_time)) / (1000 * 60 * 60));
      cost = hours * (parseFloat(entry[0].price) || 0);
    } else {
      cost = parseFloat(entry[0].price) || 0;
    }
    console.log('Calculated cost:', cost);

    const connection = await db.pool.getConnection();
    let transactionSuccess = false;
    try {
      await connection.beginTransaction();

      const [result] = await connection.query(
        'INSERT INTO exits (entry_id, exit_time, cost) VALUES (?, NOW(), ?)',
        [entry_id, cost]
      );
      console.log('Exit record inserted:', { entry_id, cost, insertId: result.insertId });

      const [deleteResult] = await connection.query(
        'DELETE FROM entries WHERE id = ?',
        [entry_id]
      );
      console.log('Entry deletion result:', { entry_id, affectedRows: deleteResult.affectedRows });

      const spacesPerVehicle = Number(entry[0].spaces_per_vehicle) || 1;
      const [updateResult] = await connection.query(
        'UPDATE parking_lot SET used_spaces = GREATEST(used_spaces - ?, 0) WHERE id = 1',
        [spacesPerVehicle]
      );
      console.log('Updated parking_lot used_spaces:', { affectedRows: updateResult.affectedRows, spacesPerVehicle });

      await connection.commit();
      transactionSuccess = true;
      console.log('Transaction committed successfully for entry_id:', entry_id);
    } catch (transactionErr) {
      console.error('Transaction error for entry_id:', { entry_id, error: transactionErr.message, stack: transactionErr.stack });
      await connection.rollback();
      console.log('Transaction rolled back for entry_id:', entry_id);
      throw transactionErr;
    } finally {
      connection.release();
      console.log('Database connection released for entry_id:', entry_id);
    }

    if (!transactionSuccess) {
      throw new Error('Transaction failed to complete for entry_id: ' + entry_id);
    }

    const [newExit] = await db.pool.query('SELECT * FROM exits WHERE entry_id = ?', [entry_id]);
    console.log('New exit record:', newExit);

    const [parkedAfter] = await db.pool.query(
      `SELECT COUNT(*) as count FROM entries`
    );
    const [earningsAfter] = await db.pool.query(
      `SELECT COALESCE(SUM(x.cost), 0) as total FROM exits x WHERE DATE(x.exit_time) = CURDATE()`
    );
    console.log('Dashboard stats after exit:', { parked: parkedAfter[0].count, earnings: earningsAfter[0].total });

    if (req.session.subscription) {
      const payload = JSON.stringify({
        title: 'Vehicle Exited',
        body: `Your vehicle ${entry[0].number_plate} has exited. Total cost: $${cost.toFixed(2)}.`
      });
      await webPush.sendNotification(req.session.subscription, payload);
    }

    // Generate the receipt content
    const receiptContent = `
      <div style="text-align: center; font-family: Arial, sans-serif; padding: 20px;">
        <h2>Parking System</h2>
        <h4>Exit Receipt</h4>
        <p><strong>Vehicle Number:</strong> ${entry[0].number_plate}</p>
        <p><strong>Category:</strong> ${entry[0].category}</p>
        <p><strong>Entry Time:</strong> ${entryTime}</p>
        <p><strong>Exit Time:</strong> ${exitTimeFormatted}</p>
        <p><strong>Total Cost:</strong> ${cost.toFixed(2)} PKR</p>
        <p><strong>Processed By:</strong> ${user.username}</p>
      </div>
    `;

    // Serve as HTML, let client-side script handle PDF generation
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Exit Receipt</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
      </head>
      <body>
        <div id="receipt">${receiptContent}</div>
        <script>
          const element = document.getElementById('receipt');
          html2pdf().from(element).save('exit_receipt_${entry[0].number_plate}_${Date.now()}.pdf');
          setTimeout(() => { window.location.href = '/dashboard?hardrefresh=${Date.now()}'; }, 1000);
        </script>
      </body>
      </html>
    `);
  } catch (err) {
    console.error('Process exit error:', err.message, err.stack);
    fs.writeFileSync('server.log', `Process exit error: ${err.message}\n${err.stack}\n`, { flag: 'a' });
    const [entries] = await db.pool.query(
      'SELECT e.id, e.number_plate, e.entry_time, e.owner_name, e.phone, e.category_id, vc.name as category, vc.pricing_type, vc.price, vc.spaces_per_vehicle ' +
      'FROM entries e LEFT JOIN vehicle_categories vc ON e.category_id = vc.id'
    );
    res.render('exit', { entries: entries || [], error: 'Failed to process exit: ' + err.message, success: null, user });
  }
});

// Add Admin Routes
app.get('/add-admin', isAuthenticated, hasPermission('add_admin'), (req, res) => {
  console.log('GET /add-admin');
  const user = req.session.admin;
  res.render('add-admin', { error: null, success: null, validationErrors: [], user });
});

app.post('/add-admin', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  const user = req.session.admin;
  const { username, password, email, can_entry, can_exit, can_manage, can_profile } = req.body;
  console.log('POST /add-admin:', { username, email, can_entry, can_exit, can_manage, can_profile });

  const validationErrors = [];
  const usernameError = validateUsername(username);
  const passwordError = validatePassword(password);
  const emailError = validateEmail(email);

  if (usernameError) validationErrors.push(usernameError);
  if (passwordError) validationErrors.push(passwordError);
  if (emailError) validationErrors.push(emailError);

  if (validationErrors.length > 0) {
    return res.render('add-admin', { error: null, success: null, validationErrors, user });
  }

  try {
    if (!username || !password || !email) {
      console.log('Missing fields');
      return res.render('add-admin', { error: 'All fields are required', success: null, validationErrors: [], user });
    }

    const [existing] = await db.pool.query('SELECT * FROM admins WHERE username = ?', [username]);
    if (existing.length > 0) {
      console.log('Username exists:', username);
      return res.render('add-admin', { error: 'Username already exists', success: null, validationErrors: [], user });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const permissions = {
      entry: can_entry === 'on',
      exit: can_exit === 'on',
      manage: can_manage === 'on',
      profile: can_profile === 'on',
      add_admin: false
    };
    await db.pool.query(
      'INSERT INTO admins (username, password, plaintext_password, email, permissions) VALUES (?, ?, ?, ?, ?)',
      [username, hashedPassword, password, email, JSON.stringify(permissions)]
    );
    console.log('Admin added:', { username, permissions });
    res.redirect('/dashboard');
  } catch (err) {
    console.error('Add admin error:', err);
    fs.writeFileSync('server.log', `Add admin error: ${err}\n`, { flag: 'a' });
    res.render('add-admin', { error: 'Failed to add admin', success: null, validationErrors: [], user });
  }
});

// Manage Admins Routes
app.get('/manage-admins', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  console.log('GET /manage-admins');
  try {
    const user = req.session.admin;
    const [admins] = await db.pool.query('SELECT id, username, email, permissions FROM admins WHERE username != ?', [user.username]);
    // Parse permissions for each admin and set a default if null or invalid
    const parsedAdmins = admins.map(admin => {
      let parsedPermissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
      if (admin.permissions) {
        try {
          parsedPermissions = { ...parsedPermissions, ...JSON.parse(admin.permissions) };
        } catch (err) {
          console.error(`Error parsing permissions for admin ${admin.username}:`, err);
        }
      }
      return { ...admin, permissions: parsedPermissions };
    });
    console.log('Admins list:', parsedAdmins);
    res.render('manage-admins', { admins: parsedAdmins, error: null, success: null, user });
  } catch (err) {
    console.error('Manage admins error:', err);
    fs.writeFileSync('server.log', `Manage admins error: ${err}\n`, { flag: 'a' });
    res.render('manage-admins', { admins: [], error: 'Server error: ' + err.message, success: null, user: req.session.admin });
  }
});

app.get('/manage-admins/confirm-delete/:id', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  console.log('GET /manage-admins/confirm-delete/:id');
  const user = req.session.admin;
  const { id } = req.params;
  try {
    const [admins] = await db.pool.query('SELECT id, username, email FROM admins WHERE id = ? AND username != ?', [id, user.username]);
    console.log('Fetched admin for deletion confirmation:', admins);
    if (admins.length === 0) {
      console.log('Admin not found for ID:', id);
      const [allAdmins] = await db.pool.query('SELECT id, username, email FROM admins WHERE username != ?', [user.username]);
      return res.render('manage-admins', { admins: allAdmins, error: 'Admin not found or cannot delete yourself', success: null, user });
    }
    const adminToDelete = admins[0];
    res.render('confirm-delete-admin', { admin: adminToDelete, error: null, success: null, user });
  } catch (err) {
    console.error('Confirm delete admin error:', err);
    fs.writeFileSync('server.log', `Confirm delete admin error: ${err}\n`, { flag: 'a' });
    const [admins] = await db.pool.query('SELECT id, username, email FROM admins WHERE username != ?', [user.username]);
    res.render('manage-admins', { admins, error: 'Server error: ' + err.message, success: null, user });
  }
});

app.get('/manage-admins/edit/:id', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  console.log('GET /manage-admins/edit/:id');
  const user = req.session.admin;
  const { id } = req.params;
  try {
    const [admins] = await db.pool.query('SELECT id, username, email, permissions, password, plaintext_password FROM admins WHERE id = ? AND username != ?', [id, user.username]);
    console.log('Fetched admin:', admins);
    if (admins.length === 0) {
      console.log('Admin not found for ID:', id);
      return res.render('manage-admins', { admins: [], error: 'Admin not found', success: null, user });
    }
    const adminToEdit = admins[0];
    let parsedPermissions = { entry: false, exit: false, manage: false, profile: false, add_admin: false };
    if (adminToEdit.permissions) {
      try {
        parsedPermissions = { ...parsedPermissions, ...JSON.parse(adminToEdit.permissions) };
      } catch (err) {
        console.error(`Error parsing permissions for admin ${adminToEdit.username}:`, err);
      }
    }
    adminToEdit.permissions = parsedPermissions;
    // Use the session's plaintext_password if available, otherwise indicate it's not set
    adminToEdit.plaintext_password = adminToEdit.plaintext_password || user.plaintext_password || '';
    console.log('Rendering edit-admin with details:', {
      id: adminToEdit.id,
      username: adminToEdit.username,
      email: adminToEdit.email,
      plaintext_password: adminToEdit.plaintext_password ? '[REDACTED]' : 'Not set',
      permissions: adminToEdit.permissions
    });
    res.render('edit-admin', { admin: adminToEdit, error: null, success: null, validationErrors: [], user });
  } catch (err) {
    console.error('Edit admin fetch error:', err);
    fs.writeFileSync('server.log', `Edit admin fetch error: ${err}\n`, { flag: 'a' });
    res.render('edit-admin', { admin: null, error: 'Server error: ' + err.message, success: null, validationErrors: [], user });
  }
});

app.post('/manage-admins/edit/:id', isAuthenticated, hasPermission('add_admin'), async (req, res) => {
  const user = req.session.admin;
  const { id } = req.params;
  const { username, email, password, can_entry, can_exit, can_manage, can_profile } = req.body;
  console.log('POST /manage-admins/edit/:id:', { id, username, email, password: password ? '[REDACTED]' : 'Not provided', can_entry, can_exit, can_manage, can_profile });

  try {
    const [admins] = await db.pool.query('SELECT id, username, email, permissions, password FROM admins WHERE id = ? AND username != ?', [id, user.username]);
    if (admins.length === 0) {
      return res.render('edit-admin', { admin: null, error: 'Admin not found', success: null, validationErrors: [], user });
    }

    const adminToEdit = admins[0];
    const validationErrors = [];
    const usernameError = validateUsername(username);
    const emailError = validateEmail(email);
    if (password) { // Only validate password if provided
      const passwordError = validatePassword(password);
      if (passwordError) validationErrors.push(passwordError);
    } else {
      validationErrors.push('Password is required');
    }

    if (usernameError) validationErrors.push(usernameError);
    if (emailError) validationErrors.push(emailError);

    const [duplicateUsername] = await db.pool.query('SELECT id FROM admins WHERE username = ? AND id != ?', [username, id]);
    if (duplicateUsername.length > 0) {
      validationErrors.push('Username already exists');
    }
    const [duplicateEmail] = await db.pool.query('SELECT id FROM admins WHERE email = ? AND id != ?', [email, id]);
    if (duplicateEmail.length > 0) {
      validationErrors.push('Email already exists');
    }

    if (validationErrors.length > 0) {
      const adminToEditForRender = { 
        id, 
        username, 
        email, 
        password,
        plaintext_password: password,
        permissions: { entry: can_entry === 'on', exit: can_exit === 'on', manage: can_manage === 'on', profile: can_profile === 'on', add_admin: false }
      };
      return res.render('edit-admin', { admin: adminToEditForRender, error: null, success: null, validationErrors, user });
    }

    const permissions = {
      entry: can_entry === 'on',
      exit: can_exit === 'on',
      manage: can_manage === 'on',
      profile: can_profile === 'on',
      add_admin: false
    };

    const hashedPassword = await bcrypt.hash(password, 10);
    await db.pool.query(
      'UPDATE admins SET username = ?, email = ?, password = ?, plaintext_password = ?, permissions = ? WHERE id = ?',
      [username, email, hashedPassword, password, JSON.stringify(permissions), id]
    );
    console.log('Admin details updated:', { id, username, email, permissions });

    // If username or password has changed, invalidate all sessions for the admin
    const usernameChanged = username !== adminToEdit.username;
    const passwordChanged = !(await bcrypt.compare(password, adminToEdit.password));
    if (usernameChanged || passwordChanged) {
      invalidateUserSessions(id, req.sessionID);
      console.log(`Invalidated sessions for admin with ID ${id} due to ${usernameChanged ? 'username' : ''}${usernameChanged && passwordChanged ? ' and ' : ''}${passwordChanged ? 'password' : ''} change`);
    }

    res.redirect('/manage-admins');
  } catch (err) {
    console.error('Edit admin update error:', err);
    fs.writeFileSync('server.log', `Edit admin update error: ${err}\n`, { flag: 'a' });
    const adminToEditForRender = { 
      id, 
      username, 
      email, 
      password,
      plaintext_password: password,
      permissions: { entry: can_entry === 'on', exit: can_exit === 'on', manage: can_manage === 'on', profile: can_profile === 'on', add_admin: false }
    };
    res.render('edit-admin', { admin: adminToEditForRender, error: 'Failed to update admin: ' + err.message, success: null, validationErrors: [], user });
  }
});

// Notification Routes
app.get('/vapidPublicKey', (req, res) => {
  res.send(vapidKeys.publicKey);
});

app.post('/subscribe', (req, res) => {
  const subscription = req.body;
  req.session.subscription = subscription;
  res.status(201).json({});
});

// Logout Route
app.get('/logout', (req, res) => {
  console.log('GET /logout');
  req.session.destroy();
  res.redirect('/login');
});

// Start Server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});Dashboard error: Error: Unknown column 'exited' in 'field list'
Dashboard error: Error: Unknown column 'exited' in 'field list'
Dashboard error: Error: Unknown column 'exited' in 'field list'
